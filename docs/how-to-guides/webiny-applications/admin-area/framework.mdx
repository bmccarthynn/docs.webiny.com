---
id: framework
title: The Framework
sidebar_label: The Framework
keywords: ["admin", "area", "framework", "extending", "extensions"]
description: Learn what makes Admin Area tick, and how extensions work.
---

import CenteredImage from "@components/CenteredImage";
import adminAppFramework from "./assets/AdminAppFramework.png";
import menuRenderers from "./assets/MenuRenderers.png";

:::info Can I Use This?
In order to follow this guide, you must use Webiny version **5.21.0** or greater.
:::

:::tip What you'll learn

- the moving parts of the Admin Area framework
- how to add custom extensions

:::

## Overview

Admin Area is powered by a simple React framework, which allows you to add new React Context providers, compose existing UI components, register routes, and do all that using plain React components, and familiar concepts, like Higher Order Components, and hooks.

In the following sections, we cover 5 fundamental components which make everything work. These 5 components make up the low-level API, and in the vast majority of cases, these are the only components you'll need to use to develop new plugins (besides your own components and views).

The following diagram shows all 5 components in action:

<CenteredImage src={adminAppFramework} title={"Admin Area Framework In Action"} />

As you can see, what you mount, is not exactly what gets rendered. The `Admin` component (the framework) takes care of rendering things _where_ and _when_ they need to be rendered, and also does various compositions and optimizations (caching) in the process.

A good example of that are the React Context providers (represented by the `Provider` component in the diagram). Traditionally, when using Higher Order Components, we end up with a deep hierarchy of nested components, which is hard to read, and even harder to maintain. In these cases, we usually resort to HOC composition, to flatten out the hierarchy, and produce a single component which is constructed of the individual HOCs wrapped around the previous one. We use the same technique to construct React Context providers.

## The `Provider` Component

When building plugins or entire applications, we often need to add one or more React Context providers to share state. Now imagine you use 10 third-party (or even your own) plugins, and each plugin has its own React Context provider. How annoying would it be to import those providers individually, and mount them one by one?

We make this easy for you, using our `Provider` component. The component accepts a single HOC, and this allows us to compose providers for you. Here's an example of a simple Provider HOC implementation:

```tsx
import React, { createContext } from "react";
import { Provider } from "@webiny/app-serverless-cms";

const MyContext = createContext({});

const MyProviderHOC = PreviousProvider => {
  return function MyProvider({ children }) {
    const myContext = {
      /* context value goes here */
    };

    return (
      <MyContext.Provider value={myContext}>
        <PreviousProvider>{children}</PreviousProvider>
      </MyContext.Provider>
    );
  };
};

// Register a new provider as a child of the <Admin> element
// NOTE: this can be anywhere in the hierarchy, grouped under a custom plugin component, etc.
export const App = () => {
  return (
    <Admin>
      <Provider hoc={MyProviderHOC} />
    </Admin>
  );
};
```

One of the important characteristics of the Provider component is that you can't interfere with the core setup of the Webiny CMS, and break it accidentally. Your Providers will _always_ be mounted lower in the hierarchy, _after_ the core Providers.

## The `Compose` Component

The `Compose` component allows you to hook into existing React components, that are _already used_ in the existing applications, intercept them at runtime, and modify or replace the content that gets rendered.

A good usage example are the menu items in the main navigation of the Admin Area application.

<CenteredImage src={menuRenderers} title={"Navigation Menu Renderers"} />

All the menu items are represented with a single underlying data structure. Depending on menu item's children, depth (menu within a menu), presence of a link (or an onClick callback), etc., different renderers need to be applied.

Instead of implementing one giant renderer for the entire navigation, we can compose multiple smaller, single-purpose renderers and let them handle individual cases. This also makes it super easy for you to modify individual renderers if the defaults are not the best fit for your project.

Here's a code example to demonstrate the usage of the `Compose` component:

```tsx
import React from "react";
// Import a component you want to compose (in this case, it's MenuItemRenderer).
import { MenuItemRenderer, useMenuItem } from "@webiny/app-serverless-cms";
import { Link } from "@webiny/react-router";

// Implement a HOC to compose with the target component
const MyMenuItemRenderer = OriginalRenderer => {
  return function MyMenuItem() {
    // Use the `useMenuItem` hook to access the current menu item being rendered.
    const { menuItem, depth } = useMenuItem();

    // Decide whether you want to handle this menu item.
    const shouldRender = depth === 0 && menuItem.path;

    if (!shouldRender) {
      // Pass the rendering to the original component.
      return <OriginalRenderer />;
    }

    // Render the menu item!
    return <Link to={menuItem.path}>{menuItem.label}</Link>;
  };
};

// Any time a MenuItemRenderer is mounted, you want to apply your component first.
// NOTE: you can register as many HOCs as you need.
export const App = () => {
  return (
    <Admin>
      <Compose component={MenuItemRenderer} with={MyMenuItemRenderer} />
    </Admin>
  );
};
```

:::info Good to know
As of version **5.21.0**, only the main layout components are composable. As we keep upgrading our apps to use the new API, more and more components will become composable.
:::

Component composition applies not only to the built-in components, but can be also used on your own components. To make your components composable, you must use the `makeComposable` utility:

```tsx title="Make Your Own Components Composable"
import React from "react";
import { makeComposable, HigherOrderComponent } from "@webiny/app-serverless-cms";

export interface MyComponentProps {
  message: string;
}

// Pass your component to the `makeComposable` utility.
// The "MyComponent" string is necessary to generate a dev-friendly displayName for ReactDevTools.
export const MyComponent = makeComposable<MyComponentProps>("MyComponent", ({ message }) => {
  return <span>{message}</span>;
});

// Let's now compose the component!
const MyComponentHOC: HigherOrderComponent<MyComponentProps> = BaseComponent => {
  return function WrappedComponent(props) {
    return (
      <div>
        I'm an interceptor!
        <BaseComponent {...props} />
      </div>
    );
  };
};

export const App = () => {
  return (
    <Admin>
      <Compose component={MyComponent} with={MyComponentHOC} />
    </Admin>
  );
};
```

With this, whenever `<MyComponent/>` is mounted anywhere in the system, your HOC will also be rendered.

## The `Extensions` Component

This component has a bit of a special treatment. Referring back to the diagram in the [Overview](#overview) section, you can notice that `<Extensions/>` element is rendered as a child of all composed Providers. This is the only, very important, difference.

You can think of extensions as atomic, single-purposed plugins that do something like adding a route, adding a menu, adding a file type renderer, etc. More and more of these components will become available as we migrate our existing plugins to this React based API.

So why do they need to render as children of all the Providers? More often than not, extensions will add functionality specific to a certain application, like Page Builder, File Manager, etc. Those applications will each have their own Providers which expose the public API via hooks. To make that API accessible, your components (extensions) need to be mounted as descendants of the React Context.

Here's the simplest, most straightforward example of using Extensions:

```tsx title="Using <Extensions/> to Add Routes and Menus"
import React from "react";
import { Admin, Extensions, AddMenu, AddRoute, Layout } from "@webiny/app-serverless-cms";

// Mount everything as children of the <Admin> element.
export const App = () => {
  return (
    <Admin>
      <Extensions>
        <AddMenu id={"myApp"} label={"My App"}>
          <AddMenu id={"myApp.records"} label={"Records"} path={"/my-app/records"} />
        </AddMenu>
        <AddRoute path={"/my-app/records"}>
          <Layout title={"My App - Records"}>{/* Your UI goes here. */}</Layout>
        </AddRoute>
      </Extensions>
    </Admin>
  );
};
```

### The `AddRoute` Component

This component is used to add routes to the Admin app (which we already saw in action, the previous section). It accepts all the props supported by `react-router` (which we use under the hood), but since it's an extension, we don't immediately mount the `<Route/>`. Instead, we register the route internally, and then mount it where and when necessary (as shown in the [Overview](#overview) section diagram).

### The `AddMenu` Component

This component is used to add navigation menu items, and supports infinite levels of nesting (as long as your menu item renderers can render them). By default, we provide renderers for the navigation shown in the [Compose component](#the-compose-component) section.

The basic usage is already shown in the [Extensions component](#the-extensions-component) section.
With that in mind, let's show a more advanced example, and demonstrate how it would work with permission checks:

```tsx title="Conditional Extensions"
import React from "react";
import {
  Admin,
  Extensions,
  AddMenu,
  AddRoute,
  Layout,
  HasPermission
} from "@webiny/app-serverless-cms";

export const MyPlugin = () => {
  return (
    <Extensions>
      {/* Only mount the top-level menu element if the user has the required permission. */}
      <HasPermission name={"myApp"}>
        <AddMenu id={"myApp"} label={"My App"}>
          {/* Only mount sub-menu element and the corresponding route, if the user has the required permission. */}
          <HasPermission name={"myApp.records"}>
            <AddMenu id={"myApp.records"} label={"Records"} path={"/my-app/records"} />
            <AddRoute path={"/my-app/records"}>
              <Layout title={"My App - Records"}>{/* Your UI goes here. */}</Layout>
            </AddRoute>
          </HasPermission>
        </AddMenu>
      </HasPermission>
    </Extensions>
  );
};

export const App = () => {
  return (
    <Admin>
      <MyPlugin />
    </Admin>
  );
};
```

## Extracting Extensions Into a Plugin

You can extract your extensions into a dedicated component, or even an NPM package, because `Admin` component doesn't care about the hierarchy, so you can mount those components anywhere. The following example shows how you would combine all the components covered in this article into a single plugin component, which adds a Provider, composes an existing React component, adds menus and routes, and even has permission checks.

```tsx title="Extract Extensions Into a Separate Component"
import React, { Fragment } from "react";
import {
  Admin,
  Extensions,
  Provider,
  Compose,
  AddMenu,
  AddRoute,
  Layout,
  HasPermission,
  MenuItemRenderer
} from "@webiny/app-serverless-cms";

export const MyPlugin = () => {
  return (
    <Fragment>
      <Provider hoc={MyProviderHOC} />
      <Compose component={MenuItemRenderer} with={MyMenuItemRenderer} />
      <Extensions>
        {/* Only mount the top-level menu element if the user has the required permission. */}
        <HasPermission name={"myApp"}>
          <AddMenu id={"myApp"} label={"My App"}>
            {/* Only mount sub-menu element and the corresponding route, if the user has the required permission. */}
            <HasPermission name={"myApp.records"}>
              <AddMenu id={"myApp.records"} label={"Records"} path={"/my-app/records"} />
              <AddRoute path={"/my-app/records"}>
                <Layout title={"My App - Records"}>{/* Your UI goes here. */}</Layout>
              </AddRoute>
            </HasPermission>
          </AddMenu>
        </HasPermission>
      </Extensions>
    </Fragment>
  );
};

export const App = () => {
  return (
    <Admin>
      <MyPlugin />
    </Admin>
  );
};
```

:::info Important
The only rule to be aware of, is that you **must** mount the `<Provider/>` element _outside_ of the `<Extensions/>` element. `<Compose/>` can go anywhere, as it doesn't affect the app hierarchy.
:::

## Naming Conventions

There are many components exported from the `@webiny/app-serverless-cms` package. These naming conventions will help you find your way around, and quickly filter out components in your IDE.

- components that _add_ things to the system start with `Add` prefix (e.g., `AddMenu`)
- presentation components end with `Renderer` (e.g., `MenuItemRenderer`)
- hooks, by React convention, start with `use` (e.g., `useSecurity`)

Almost always, renderer components go with a parent component that provides a React Context to the renderer. For example, a `UserMenuItem` has a corresponding `UserMenuItemRenderer` component. The renderer component doesn't take any props; instead, it uses hooks to fetch the relevant data from React Context, provided by the `UserMenuItem` component. This approach drastically reduces prop drilling, and makes it easier to decouple logic from presentation. This topic will be covered in more details in a dedicated article.

If you want to change the appearance (the renderer) of a certain component, always look for the `Renderer` part of it, and compose _that_ component.

## Conclusion

These few simple components is what makes up the core of the Admin Area application. This provides strong and simple fundamentals to build upon. It's easily composable, and gives the ability to lazy-load plugins, apply extensions conditionally, compose component renderers, and also compose these atomic components into larger plugins.

:::tip
In the prior versions of Webiny, we relied on a global plugins registry, and plugins as objects. This approach still works, and all your existing plugins will work as if nothing changed.

However, the core Webiny apps will slowly be transitioning to this new React based API, and we'll be exposing more extension components as we go.
:::
